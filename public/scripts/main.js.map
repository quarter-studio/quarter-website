{"version":3,"file":"main.js","sources":["../../scripts/main.js"],"sourcesContent":["import '../styles/all.scss'\n// vertex shader\nconst vs = `\nattribute vec4 position;\n\nvoid main() {\n  gl_Position = position;\n}\n`;\n\n//fragment shader\nconst fs = `\n// Author: Tobias Toft\n// Title: Mountain ridges for Quarter Studio, v. 0.0.1\n// Heavily inspired by and based on the 'noise holes' shader found here: https://www.shadertoy.com/view/XdyXz3\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform sampler2D u_texture;\nuniform sampler2D u_ashima1;\nuniform sampler2D u_ashima2;\n\n// Generic random\nfloat random(vec2 st) {\n  float a = 12.9898;\n  float b = 78.233;\n  float c = 43758.5453;\n  float dt= dot(st.xy ,vec2(a,b));\n  float sn= mod(dt,3.14);\n  return fract(sin(sn) * c);\n}\n\nfloat whiteNoise(in vec2 p){\n  vec2 tv = p * vec2(u_resolution.x/256., u_resolution.y/256.); // * vec2(1.,float(u_resolution.y/u_resolution.x));\n  return (texture2D(u_texture, tv).r);\n}\n\n// Perlin noise\nfloat snoise(in vec2 p){\n  vec2 tv = p * vec2(u_resolution.x/2048., u_resolution.y/2048.); // * vec2(1.,float(u_resolution.y/u_resolution.x));\n  vec4 tex = texture2D(u_ashima1, tv);\n  //float val = (tex.r + tex.g + tex.b)/3.;\n  return tex.r;\n}\n\n// Perlin noise with two octaves\nfloat snoise2(in vec2 p){\n  vec2 tv = p * vec2(u_resolution.x/2048., u_resolution.y/2048.); // * vec2(1.,float(u_resolution.y/u_resolution.x));\n  vec4 tex = texture2D(u_ashima2, tv);\n  //float val = (tex.r + tex.g + tex.b)/3.;\n  return tex.r;\n}\n\n//--\n\nconst float STEPS = 4.;\nconst float LINE_WIDTH = 0.002;\nconst float CUTOFF = 0.5;\nfloat posX = u_mouse.x * 0.1;\nfloat posY = u_mouse.y * 0.1;\nvec2 mouseUV = u_mouse / u_resolution;\n\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat2 rotate2d(float a){\n  return mat2(\n      cos(a), -sin(a),\n      sin(a), cos(a)\n  );\n}\n\nfloat getNoise(vec2 uv, float t){\n  //given a uv coord and time - return a noise val in range 0 - 1\n  //using baked ashima noise\n\n  //octave 1\n  const float SCALEX = 1.;\n  const float SCALEY = 1.;\n  //float noise = snoise( vec2(uv.x * SCALEX + posX + t, (uv.y * SCALEY + t)));\n  float noise = snoise( rotate2d(sin(t*0.1) + posY * 2.) * vec2(uv.x * SCALEX + posX + t, uv.y * SCALEY + posY + t));\n\n  //octave 2\n  // NOTE: Disabling mixing two noise textures for now until I find a higher res/bitdepth way of doing it\n  //noise += snoise2( vec2(uv.x * SCALEX + t, uv.y * SCALEY + t)) * 0.2 ;\n\n  //move noise into 0 - 1 range\n  //noise = (noise/2. + 0.5);\n\n  return noise;\n}\n\nfloat getDepth(float n){\n  //remap remaining non-cutoff region to 0 - 1\n  //float cutoff = posY + 0.5;\n  float d = (n - CUTOFF) / (1. - CUTOFF);\n\n  //step\n  d = floor(d*STEPS)/STEPS;\n\n  return d;\n}\n\nvoid main(){\n  float t = u_time * 0.01;\n  vec2 uv = gl_FragCoord.xy / u_resolution;\n  vec3 col = vec3(0);\n\n  float noise = getNoise(uv, t);\n  float d = getDepth(noise);\n\n  //calc HSV color\n  float h = 0.5;// + (d * 0.3); //= d + 0.2; //rainbow hue\n  float s = 0.;\n  float v = 0.; //deeper is darker\n\n  // //get depth at offset position (needed for outlining)\n  // float noiseOffY = getNoise(uv + vec2(0, LINE_WIDTH), t);\n  // float noiseOffX = getNoise(uv + vec2(LINE_WIDTH, 0), t);\n  // float dOffY = getDepth(noiseOffY);\n  // float dOffX = getDepth(noiseOffX);\n\n  float WIDEN = 1. + (sin(t)+1.)/2. * 1.5;\n  const int STEPS = 16;\n  for (int j=0; j<STEPS; j++){\n    vec2 dOffset = vec2(\n      getDepth(getNoise(uv + vec2(0, LINE_WIDTH) * WIDEN * pow(float(j), 1.25), t)),\n      getDepth(getNoise(uv + vec2(0, -LINE_WIDTH) * WIDEN * pow(float(j), 1.25), t))\n    );\n\n\n    // // Save for later\n    // vec4 dOffset = vec4(\n    //   getDepth(getNoise(uv + vec2(LINE_WIDTH, 0) * WIDEN * pow(float(j), 1.25), t)),\n    //   getDepth(getNoise(uv + vec2(0, LINE_WIDTH) * WIDEN * pow(float(j), 1.25), t)),\n    //   getDepth(getNoise(uv + vec2(-LINE_WIDTH, 0) * WIDEN * pow(float(j), 1.25), t)),\n    //   getDepth(getNoise(uv + vec2(0, -LINE_WIDTH) * WIDEN * pow(float(j), 1.25), t))\n    // );\n\n\n    if (d != dOffset.x || d != dOffset.y){\n    //if (d != dOffset.x || d != dOffset.y || d != dOffset.z || d != dOffset.w){ // Save for later\n      h = 0.; //(uv.x * 0.1) + 0.5;\n      s = 0.;\n      v += .0625 * floor( whiteNoise(uv*2.) + 0.2 * float(STEPS)/float(j+1)); // + (0.2 * float(STEPS)/float(j+1)) );\n      if (d != dOffset.x){\n        v *= 0.75;\n      }\n    }\n  }\n\n  // // // Outline ridges\n  // if (d != dOffX || d != dOffY){\n  //   h = (d * 0.1) + (sin(t) + 1.)/2.;\n  //   s = .3;\n  //   v = (sin(t)+1.)/2. + d + 0.5;\n  //   //v *= 0.25;\n  // }\n\n  col = hsv2rgb(vec3(h,s,v));\n\n  //add vertical gradient\n  col *= 0.2 + (gl_FragCoord.y/u_resolution.y) * 0.8;\n\n  //add noise texture\n  //col += 0.1 * whiteNoise(uv + random(vec2(u_time, 0)));\n\n  gl_FragColor = vec4(col, 1.0);\n  //gl_FragColor = vec4(noise, noise, noise, 1.0);\n}\n`;\n\n// get mouse position for GL uniform\nfunction getRelativeMousePosition(event, target) {\n  target = target || event.target;\n  var rect = target.getBoundingClientRect();\n\n  return {\n    x: event.clientX - rect.left,\n    y: event.clientY - rect.top,\n  }\n}\n\n// assumes target or event.target is canvas\nfunction getNoPaddingNoBorderCanvasRelativeMousePosition(event, target) {\n  target = target || event.target;\n  var pos = getRelativeMousePosition(event, target);\n\n  pos.x = pos.x * target.width  / target.clientWidth;\n  pos.y = pos.y * target.height / target.clientHeight;\n\n  return pos;\n}\n\n// resize canvas\nfunction resize(canvas) {\n  // Lookup the size the browser is displaying the canvas.\n  var displayWidth  = canvas.clientWidth;\n  var displayHeight = canvas.clientHeight;\n\n  // Check if the canvas is not the same size.\n  if (canvas.width  !== displayWidth ||\n      canvas.height !== displayHeight) {\n\n    // Make the canvas the same size\n    canvas.width  = displayWidth;\n    canvas.height = displayHeight;\n  }\n}\n\n\n// init webgl\nconst mousePos = {x: 0, y: 0};\nconst gl = document.getElementById(\"c\").getContext(\"webgl\");\nconst programInfo = twgl.createProgramInfo(gl, [vs, fs]);\n\nconst arrays = {\n  position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],\n};\n\nconst bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\nconst textures = twgl.createTextures(gl, {\n  noise: { src: \"/images/noise.png\", mag: gl.NEAREST },\n  ashima1: { src: \"/images/ashima1.png\" },\n  ashima2: { src: \"/images/ashima2.png\" }\n});\n\nfunction render(time) {\n  twgl.resizeCanvasToDisplaySize(gl.canvas, 1); //use window.devicePixelRatio if you want retina, we might not though...\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n  const uniforms = {\n    u_time: time * 0.001,\n    u_resolution: [gl.canvas.width, gl.canvas.height],\n    u_mouse: [mousePos.x, mousePos.y],\n    u_texture: textures.noise,\n    u_ashima1: textures.ashima1,\n    u_ashima2: textures.ashima2\n  };\n\n  gl.useProgram(programInfo.program);\n  twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n  twgl.setUniforms(programInfo, uniforms);\n  twgl.drawBufferInfo(gl, bufferInfo);\n\n  requestAnimationFrame(render);\n}\n\nrequestAnimationFrame(render);\n\n\n// attach listener for updating mouse position uniform\nwindow.addEventListener('mousemove', e => {\n  const pos = getNoPaddingNoBorderCanvasRelativeMousePosition(e, gl.canvas);\n\n  // pos is in pixel coordinates for the canvas.\n  // so convert to WebGL clip space coordinates\n  const x = pos.x / gl.canvas.width  *  2 - 1;\n  const y = pos.y / gl.canvas.height * -2 + 1;\n\n  // mousePos.x = x;\n  // mousePos.y = y;\n});"],"names":["render","time","twgl","resizeCanvasToDisplaySize","gl","canvas","viewport","width","height","u_time","u_resolution","u_mouse","mousePos","x","y","u_texture","textures","noise","u_ashima1","ashima1","u_ashima2","ashima2","useProgram","programInfo","program","setBuffersAndAttributes","bufferInfo","setUniforms","uniforms","drawBufferInfo","requestAnimationFrame","position","src","mag","NEAREST","window","addEventListener","e","target","getBoundingClientRect"],"mappings":"yBA4OAA,QAASA,EAAM,CAACC,CAAD,CAAO,CACpBC,IAAAC,0BAAA,CAA+BC,CAAAC,OAA/B,CAA0C,CAA1C,CACAD,EAAAE,SAAA,CAAY,CAAZ,CAAe,CAAf,CAAkBF,CAAAC,OAAAE,MAAlB,CAAmCH,CAAAC,OAAAG,OAAnC,KAGEC,OAAe,IAAfA,CAAQR,EACRS,aAAc,CAACN,CAAAC,OAAAE,MAAD,CAAkBH,CAAAC,OAAAG,OAAlB,EACdG,QAAS,CAACC,CAAAC,EAAD,CAAaD,CAAAE,EAAb,EACTC,UAAWC,CAAAC,OACXC,UAAWF,CAAAG,SACXC,UAAWJ,CAAAK,SAGbjB,EAAAkB,WAAA,CAAcC,CAAAC,QAAd,CACAtB,KAAAuB,wBAAA,CAA6BrB,CAA7B,CAAiCmB,CAAjC,CAA8CG,CAA9C,CACAxB,KAAAyB,YAAA,CAAiBJ,CAAjB,CAA8BK,CAA9B,CACA1B,KAAA2B,eAAA,CAAoBzB,CAApB,CAAwBsB,CAAxB,CAEAI,sBAAA,CAAsB9B,CAAtB,CAlBoB,CAftB,SAAmB,EAAGc,EAAG,EAAzB,mDAAA,4BAE6C,8EAAA;w1JAAA,EAF7C;qCAKEiB,SAAU,CAAE,EAAF,CAAM,EAAN,CAAS,CAAT,CAAY,CAAZ,CAAgB,EAAhB,CAAmB,CAAnB,CAAuB,EAAvB,CAA0B,CAA1B,CAA6B,CAA7B,CAAiC,EAAjC,CAAoC,CAApC,CAAuC,CAAvC,CAA0C,CAA1C,CAA8C,EAA9C,CAAiD,CAAjD,CAAoD,CAApD,CAAuD,CAAvD,CAA0D,CAA1D,GALZ,yBASuC,CACrCd,MAAO,CAAEe,IAAK,mBAAP,CAA4BC,IAAK7B,CAAA8B,QAAjC,CAD8B,CAErCf,QAAS,CAAEa,IAAK,qBAAP,CAF4B,CAGrCX,QAAS,CAAEW,IAAK,qBAAP,CAH4B,EA2BvCF,sBAAA,CAAsB9B,CAAtB,CAIAmC,OAAAC,iBAAA,CAAwB,WAAxB,CAAqCC,CAAA,EAAK,CACqBhC,IAAAA,EAAAD,CAAAC,OA/E7DiC,EAAA,EAWAA,CAXA,CAWSA,CAXT,GAWmBA,OAXnB,IAAmBA,OACRA,EAAAC,sBAAA,EA6E6B,CAA1C;"}