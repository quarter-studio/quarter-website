{"version":3,"file":"main.js","sources":["../../scripts/main.js"],"sourcesContent":["import '../styles/all.scss'\n// vertex shader\nconst vs = `\nattribute vec4 position;\n\nvoid main() {\n  gl_Position = position;\n}\n`;\n\n//fragment shader\nconst fs = `\n// Author: Tobias Toft\n// Title: Mountain ridges for Quarter Studio, v. 0.0.1\n// Heavily inspired by and based on the 'noise holes' shader found here: https://www.shadertoy.com/view/XdyXz3\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform sampler2D u_texture;\nuniform sampler2D u_ashima1;\nuniform sampler2D u_ashima2;\n\n// Generic random\nfloat random(vec2 st) {\n  float a = 12.9898;\n  float b = 78.233;\n  float c = 43758.5453;\n  float dt= dot(st.xy ,vec2(a,b));\n  float sn= mod(dt,3.14);\n  return fract(sin(sn) * c);\n}\n\nfloat whiteNoise(in vec2 p){\n  vec2 tv = p * vec2(u_resolution.x/256., u_resolution.y/256.); // * vec2(1.,float(u_resolution.y/u_resolution.x));\n  return (texture2D(u_texture, tv).r);\n}\n\n// Perlin noise\nfloat snoise(in vec2 p){\n  vec2 tv = p * vec2(u_resolution.x/2048., u_resolution.y/2048.); // * vec2(1.,float(u_resolution.y/u_resolution.x));\n  vec4 tex = texture2D(u_ashima1, tv);\n  //float val = (tex.r + tex.g + tex.b)/3.;\n  return tex.r;\n}\n\n// Perlin noise with two octaves\nfloat snoise2(in vec2 p){\n  vec2 tv = p * vec2(u_resolution.x/2048., u_resolution.y/2048.); // * vec2(1.,float(u_resolution.y/u_resolution.x));\n  vec4 tex = texture2D(u_ashima2, tv);\n  //float val = (tex.r + tex.g + tex.b)/3.;\n  return tex.r;\n}\n\n//--\n\nconst float STEPS = 4.;\nconst float LINE_WIDTH = 0.002;\nconst float CUTOFF = 0.5;\nfloat posX = u_mouse.x * 0.1;\nfloat posY = u_mouse.y * 0.1;\nvec2 mouseUV = u_mouse / u_resolution;\n\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat2 rotate2d(float a){\n  return mat2(\n      cos(a), -sin(a),\n      sin(a), cos(a)\n  );\n}\n\nfloat getNoise(vec2 uv, float t){\n  //given a uv coord and time - return a noise val in range 0 - 1\n  //using baked ashima noise\n\n  //octave 1\n  const float SCALEX = 1.;\n  const float SCALEY = 1.;\n  //float noise = snoise( vec2(uv.x * SCALEX + posX + t, (uv.y * SCALEY + t)));\n  float noise = snoise( rotate2d(sin(t*0.1) + posY * 2.) * vec2(uv.x * SCALEX + posX + t, uv.y * SCALEY + posY + t));\n\n  //octave 2\n  // NOTE: Disabling mixing two noise textures for now until I find a higher res/bitdepth way of doing it\n  //noise += snoise2( vec2(uv.x * SCALEX + t, uv.y * SCALEY + t)) * 0.2 ;\n\n  //move noise into 0 - 1 range\n  //noise = (noise/2. + 0.5);\n\n  return noise;\n}\n\nfloat getDepth(float n){\n  //remap remaining non-cutoff region to 0 - 1\n  //float cutoff = posY + 0.5;\n  float d = (n - CUTOFF) / (1. - CUTOFF);\n\n  //step\n  d = floor(d*STEPS)/STEPS;\n\n  return d;\n}\n\nvoid main(){\n  float t = u_time * 0.01;\n  vec2 uv = gl_FragCoord.xy / u_resolution;\n  vec3 col = vec3(0);\n\n  float noise = getNoise(uv, t);\n  float d = getDepth(noise);\n\n  //calc HSV color\n  float h = 0.5;// + (d * 0.3); //= d + 0.2; //rainbow hue\n  float s = 0.;\n  float v = 0.; //deeper is darker\n\n  // //get depth at offset position (needed for outlining)\n  // float noiseOffY = getNoise(uv + vec2(0, LINE_WIDTH), t);\n  // float noiseOffX = getNoise(uv + vec2(LINE_WIDTH, 0), t);\n  // float dOffY = getDepth(noiseOffY);\n  // float dOffX = getDepth(noiseOffX);\n\n  float WIDEN = 1. + (sin(t)+1.)/2. * 1.5;\n  const int STEPS = 16;\n  for (int j=0; j<STEPS; j++){\n    vec2 dOffset = vec2(\n      getDepth(getNoise(uv + vec2(0, LINE_WIDTH) * WIDEN * pow(float(j), 1.25), t)),\n      getDepth(getNoise(uv + vec2(0, -LINE_WIDTH) * WIDEN * pow(float(j), 1.25), t))\n    );\n\n\n    // // Save for later\n    // vec4 dOffset = vec4(\n    //   getDepth(getNoise(uv + vec2(LINE_WIDTH, 0) * WIDEN * pow(float(j), 1.25), t)),\n    //   getDepth(getNoise(uv + vec2(0, LINE_WIDTH) * WIDEN * pow(float(j), 1.25), t)),\n    //   getDepth(getNoise(uv + vec2(-LINE_WIDTH, 0) * WIDEN * pow(float(j), 1.25), t)),\n    //   getDepth(getNoise(uv + vec2(0, -LINE_WIDTH) * WIDEN * pow(float(j), 1.25), t))\n    // );\n\n\n    if (d != dOffset.x || d != dOffset.y){\n    //if (d != dOffset.x || d != dOffset.y || d != dOffset.z || d != dOffset.w){ // Save for later\n      h = 0.; //(uv.x * 0.1) + 0.5;\n      s = 0.;\n      v += .0625 * floor( whiteNoise(uv*2.) + 0.2 * float(STEPS)/float(j+1)); // + (0.2 * float(STEPS)/float(j+1)) );\n      if (d != dOffset.x){\n        v *= 0.75;\n      }\n    }\n  }\n\n  // // // Outline ridges\n  // if (d != dOffX || d != dOffY){\n  //   h = (d * 0.1) + (sin(t) + 1.)/2.;\n  //   s = .3;\n  //   v = (sin(t)+1.)/2. + d + 0.5;\n  //   //v *= 0.25;\n  // }\n\n  col = hsv2rgb(vec3(h,s,v));\n\n  //add vertical gradient\n  col *= 0.2 + (gl_FragCoord.y/u_resolution.y) * 0.8;\n\n  //add noise texture\n  //col += 0.1 * whiteNoise(uv + random(vec2(u_time, 0)));\n\n  gl_FragColor = vec4(col, 1.0);\n  //gl_FragColor = vec4(noise, noise, noise, 1.0);\n}\n`;\n\nfunction getWindowWidth() {\n  return window.innerWidth\n  || document.documentElement.clientWidth\n  || document.body.clientWidth;\n}\n\nfunction getWindowHeight() {\n  return window.innerHeight\n  || document.documentElement.clientHeight\n  || document.body.clientHeight;\n}\n\nfunction getScrollTop() {\n  return document.body.scrollTop\n  || document.documentElement.scrollTop;\n}\n\n// get mouse position for GL uniform\nfunction getRelativeMousePosition(event, target) {\n  target = target || event.target;\n  var rect = target.getBoundingClientRect();\n\n  return {\n    x: event.clientX - rect.left,\n    y: event.clientY - rect.top,\n  }\n}\n\n// assumes target or event.target is canvas\nfunction getNoPaddingNoBorderCanvasRelativeMousePosition(event, target) {\n  target = target || event.target;\n  var pos = getRelativeMousePosition(event, target);\n\n  pos.x = pos.x * target.width  / target.clientWidth;\n  pos.y = pos.y * target.height / target.clientHeight;\n\n  return pos;\n}\n\n// resize canvas\nfunction resize(canvas) {\n  // Lookup the size the browser is displaying the canvas.\n  var displayWidth  = canvas.clientWidth;\n  var displayHeight = canvas.clientHeight;\n\n  // Check if the canvas is not the same size.\n  if (canvas.width  !== displayWidth ||\n      canvas.height !== displayHeight) {\n\n    // Make the canvas the same size\n    canvas.width  = displayWidth;\n    canvas.height = displayHeight;\n  }\n}\n\n\n// init webgl\nlet disabled = false;\n// const mousePos = {x: 0, y: 0};\nconst gl = document.getElementById(\"c\").getContext(\"webgl\");\nconst programInfo = twgl.createProgramInfo(gl, [vs, fs]);\n\nconst arrays = {\n  position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],\n};\n\nconst bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\nconst textures = twgl.createTextures(gl, {\n  noise: { src: \"/images/noise.png\", mag: gl.NEAREST },\n  ashima1: { src: \"/images/ashima1.png\" },\n  ashima2: { src: \"/images/ashima2.png\" }\n});\n\nconst uniforms = {\n  u_mouse: [0, 0],\n  u_texture: textures.noise,\n  u_ashima1: textures.ashima1,\n  u_ashima2: textures.ashima2\n};\n\ngl.useProgram(programInfo.program);\ntwgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\nfunction render(time) {\n  requestAnimationFrame(render);\n\n  if (disabled) return;\n\n  console.log('render');\n\n  uniforms.u_time = time * 0.001;\n\n  twgl.setUniforms(programInfo, uniforms);\n  twgl.drawBufferInfo(gl, bufferInfo);\n}\n\nrequestAnimationFrame(render);\n\nfunction onMouseMove(e) {\n  // const pos = getNoPaddingNoBorderCanvasRelativeMousePosition(e, gl.canvas);\n\n  // pos is in pixel coordinates for the canvas.\n  // so convert to WebGL clip space coordinates\n  // const x = pos.x / gl.canvas.width  *  2 - 1;\n  // const y = pos.y / gl.canvas.height * -2 + 1;\n\n  // mousePos.x = x;\n  // mousePos.y = y;\n\n  // uniforms.u_mouse = [x, y]\n};\n\n// attach listener for updating mouse position uniform\nwindow.addEventListener('mousemove', onMouseMove);\n\nfunction onWindowResize() {\n  var pixelRatio = getWindowWidth() < 700 ?  window.devicePixelRatio : 1;\n  twgl.resizeCanvasToDisplaySize(gl.canvas, pixelRatio);\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n  uniforms.u_resolution = [gl.canvas.width, gl.canvas.height];\n}\n\nwindow.addEventListener('resize', onWindowResize)\n\nfunction onWindowScroll(e) {\n  disabled = getScrollTop() > getWindowHeight() \n}\n\nwindow.addEventListener('scroll', onWindowScroll)\n\nonWindowResize()\nonWindowScroll()\nonMouseMove()\n"],"names":["render","time","requestAnimationFrame","disabled","console","log","uniforms","u_time","twgl","setUniforms","programInfo","drawBufferInfo","gl","bufferInfo","onWindowResize","resizeCanvasToDisplaySize","canvas","pixelRatio","window","innerWidth","document","documentElement","clientWidth","body","devicePixelRatio","viewport","width","height","u_resolution","onWindowScroll","e","scrollTop","innerHeight","clientHeight","position","noise","src","mag","NEAREST","ashima1","ashima2","u_mouse","u_texture","textures","u_ashima1","u_ashima2","useProgram","program","setBuffersAndAttributes","addEventListener","onMouseMove"],"mappings":"yBAwQAA,QAASA,EAAM,CAACC,CAAD,CAAO,CACpBC,qBAAA,CAAsBF,CAAtB,CAEIG,EAAJ,GAEAC,OAAAC,IAAA,CAAY,QAAZ,CAKA,CAHAC,CAAAC,OAGA,CAHyB,IAGzB,CAHkBN,CAGlB,CADAO,IAAAC,YAAA,CAAiBC,CAAjB,CAA8BJ,CAA9B,CACA,CAAAE,IAAAG,eAAA,CAAoBC,CAApB,CAAwBC,CAAxB,CAPA,CAHoB,CAgCtBC,QAASA,EAAc,EAAG,CAExBN,IAAAO,0BAAA,CAA+BH,CAAAI,OAA/B,CADoC,GAAnBC,EAnHVC,MAAAC,WAmHUF,EAlHdG,QAAAC,gBAAAC,YAkHcL,EAjHdG,QAAAG,KAAAD,YAiHcL,EAA0BC,MAAAM,iBAA1BP,CAAoD,CACrE,CACAL,EAAAa,SAAA,CAAY,CAAZ,CAAe,CAAf,CAAkBb,CAAAI,OAAAU,MAAlB,CAAmCd,CAAAI,OAAAW,OAAnC,CACArB,EAAAsB,aAAA,CAAwB,CAAChB,CAAAI,OAAAU,MAAD,CAAkBd,CAAAI,OAAAW,OAAlB,CAJA,CAS1BE,QAASA,EAAc,CAACC,CAAD,CAAI,CACzB3B,CAAA,EAhHOiB,QAAAG,KAAAQ,UAgHP,EA/GGX,QAAAC,gBAAAU,UA+GH,GAtHOb,MAAAc,YAsHP;AArHGZ,QAAAC,gBAAAY,aAqHH,EApHGb,QAAAG,KAAAU,aAoHH,CADyB,CAnE3B,IAAI9B,EAAW,CAAA,CAAf,mDAAA,4BAG6C,8EAAA,y1JAAA,EAH7C;qCAME+B,SAAU,CAAE,EAAF,CAAM,EAAN,CAAS,CAAT,CAAY,CAAZ,CAAgB,EAAhB,CAAmB,CAAnB,CAAuB,EAAvB,CAA0B,CAA1B,CAA6B,CAA7B,CAAiC,EAAjC,CAAoC,CAApC,CAAuC,CAAvC,CAA0C,CAA1C,CAA8C,EAA9C,CAAiD,CAAjD,CAAoD,CAApD,CAAuD,CAAvD,CAA0D,CAA1D,GANZ,yBAUuC,CACrCC,MAAO,CAAEC,IAAK,mBAAP,CAA4BC,IAAKzB,CAAA0B,QAAjC,CAD8B,CAErCC,QAAS,CAAEH,IAAK,qBAAP,CAF4B,CAGrCI,QAAS,CAAEJ,IAAK,qBAAP,CAH4B,EAVvC,IAiBEK,QAAS,CAAC,CAAD,CAAI,CAAJ,EACTC,UAAWC,CAAAR,OACXS,UAAWD,CAAAJ,SACXM,UAAWF,CAAAH,SAGb5B,EAAAkC,WAAA,CAAcpC,CAAAqC,QAAd,CACAvC,KAAAwC,wBAAA,CAA6BpC,CAA7B,CAAiCF,CAAjC,CAA8CG,CAA9C,CAeAX,sBAAA,CAAsBF,CAAtB,CAiBAkB,OAAA+B,iBAAA,CAAwB,WAAxB,CAfAC,QAAoB,CAACpB,CAAD,CAAI,EAexB,CASAZ,OAAA+B,iBAAA,CAAwB,QAAxB,CAAkCnC,CAAlC,CAMAI,OAAA+B,iBAAA,CAAwB,QAAxB;AAAkCpB,CAAlC,CAEAf,EAAA,EACAe,EAAA;"}